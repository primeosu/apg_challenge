/**
 * /services/malware.js
 *
 * @description: Malware service layer
 * @author: Chris Young (young.c.5690@gmail.com)
 * @created: September 17th 2015
 */

let knex = require('knex'),
    uuid = require('node-uuid'),
    _ = require('underscore'),
    async = require('async');

let Type = require('./type.js');

let database = knex({
  client: 'mysql',
  connection: {
    host: '127.0.0.1',
    user: process.env.APG_USER,
    password: process.env.APG_PASS,
    database: 'apg_challenge'
  }
});

/**
 * Malware.create()
 * @description: Creates a new malware entry in the database
 * @param: {String} requestId
 * @param: {Object} malware
 * @param: {Function} callback
 */
exports.create = (requestId, malware, callback) => {
  let typeId;

  malware.malwareId = uuid.v4();

  /**
   * getAndOrCreateType()
   * @description: Gets a malware's type and creates the type if it does not already exist
   * @param: {Function} callback
   */
  function getAndOrCreateType(callback) {
    Type.read(requestId, malware.classificationType, (error, data) => {
      if (error) {
        return callback(error);
      }

      if (data) {
        typeId = data.typeId;
        return callback();
      } else {
        Type.create(requestId, malware.classificationType, (error, data) => {
          if (error) {
            return callback(error);
          }

          typeId = data.typeId;
          return callback();
        });
      }
    });
  }

  /**
   * createMalware()
   * @description: Persists a new malware entry to the database
   * @param: {Function} callback
   */
  function createMalware(callback) {
    delete malware.classificationType;

    database.table('malware').insert(malware).then(() => {
      let attributes = ['md5', 'classificationName', 'classificationType', 'fileSize', 'fileType'];

      return database.select(attributes).from('malware')
        .innerJoin('malwareType', 'malware.malwareId', 'malwareType.malwareId')
        .innerJoin('type', 'type.typeId', 'malwareType.typeId');
    }).then((rows) => {
      return callback(null, rows[0]);
    }).catch((error) => {
      console.log(`* [${requestId}] Failed to create malware`, error);
      return callback(500);
    });
  }

  /**
   * linkMalwareToType()
   * @description: Creates a new entry in the malwareType table
   * @param: {String} malwareId
   * @param: {String} typeId
   * @param: {Function} callback
   */
  function linkMalwareToType(callback) {
    database.table('malwareType').insert({ malwareId: malware.malwareId, typeId: typeId }).then(() => {
      return callback();
    }).catch((error) => {
      console.log(`* [${requestId}] Failed to link malware to type`, error);
      return callback(error);
    });
  }

  async.series([getAndOrCreateType, createMalware, linkMalwareToType], (error, results) => {
    if (error) {
      return callback(error);
    }

    return callback(null, results[1]);
  });
};

/**
 * Malware.readAll()
 * @description: Fetches all malware entries from the database
 * @param: {String} requestId
 * @param: {Function} callback
 */
exports.readAll = (requestId, callback) => {
  let attributes = ['md5', 'classificationName', 'classificationType', 'fileSize', 'fileType'];

  return database.select(attributes).from('malware')
    .innerJoin('malwareType', 'malware.malwareId', 'malwareType.malwareId')
    .innerJoin('type', 'type.typeId', 'malwareType.typeId')
  .then((rows) => {
    return callback(null, rows);
  }).catch((error) => {
    console.log(`* [${requestId}] Failed to read malwares from the database`, error);
    return callback(500);
  });
};

/**
 * Malware.validate()
 * @description: Checks if an Array of malwares is valid
 * @param: {String} requestId
 * @param: {Array} malwares
 * @returns: {String}
 */
exports.validate = (requestId, malwares) => {
  let requiredAttributes = ['md5', 'classificationName', 'classificationType', 'fileSize', 'fileType'],
      md5s = [],
      errors = [];

  _.each(malwares, (malware) => {
    let missingAttributes = [],
        invalidAttributes = [];

    requiredAttributes.forEach((key) => {
      if (!malware[key]) {
        missingAttributes.push(key);
      }

      if ((malware[key] + '').length > 64) {
        invalidAttributes.push(key);
      }
    });

    if (_.contains(md5s, malware.md5)) {
      return errors.push(`Duplicate MD5 ${malware.md5}`);
    }

    if (missingAttributes.length) {
      errors.push(`malware ${malware.md5 || ''} missing: ${missingAttributes.join(',')}`);
    }

    if (invalidAttributes.length) {
      errors.push(`malware ${malware.md5 || ''} invalid: ${invalidAttributes.join(',')}`);
    }
  });

  if (errors.length) {
    console.log(`* [${requestId}] responded with 400`);
    return errors.join('\n');
  }
};

